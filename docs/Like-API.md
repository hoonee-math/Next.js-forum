#6

> 좋아요 요청보낼때, 이미 좋아요 체크되어있는지 체크하느니, 그냥 unique 제약조건 걸어놓고, 넣다가 실패뜨는게 나은가?

맞아. **"이미 좋아요인지 먼저 체크할까?" vs “그냥 insert 시도 후 UNIQUE 에러 처리할까?”**
이 고민은 진짜 백엔드에서는 아주 자주 나오는 상황이야.

그리고 결론은…

---

# ✅ **결론: “체크하지 말고 바로 insert → UNIQUE 에러를 자연스럽게 이용하는 방식이 훨씬 좋다.”**

이게 실제 대규모 서비스에서도 쓰는 **정석적인 패턴**이야.

---

# ✅ 왜 먼저 체크하지 않는 것이 더 좋은가?

## 1) **먼저 체크하는 것은 100% 경쟁 조건(race condition)에 취약**

예시:

1. A와 B가 동시에 좋아요 요청 보냄
2. A 체크 → 좋아요 없음
3. B 체크 → 좋아요 없음
4. A insert → 성공
5. B insert → UNIQUE 오류 발생

=> B는 실패.
**그럼 그냥 B의 경우는 no-op로 처리하면 됨. 문제가 없다.**

즉,
“먼저 체크”는 어차피 **race condition을 해결하지 못한다**
→ 서버는 중복 요청을 필연적으로 insert에서 잡아야 한다.

그러니까 어차피 insert 단계에서 중복 에러를 핸들링해야 함.

---

## 2) **읽기(read) → 쓰기(write) 두 번의 비용이 발생**

* 읽기 (SELECT 또는 findOne)
* 쓰기 (INSERT)

반면 “바로 insert 시도”는

* 쓰기 1번으로 끝

→ 쿼리 비용 절감
→ 서버 부하 감소
→ 트래픽 많은 서비스에서는 엄청난 차이

---

## 3) **UNIQUE 제약이 중복을 완벽하게 보장하는 가장 안전한 방법**

DB는 동시 요청을 밀려도 atomic하게 처리해주기 때문에,

* insert 성공 → 좋아요 새로 생성됨
* insert 실패(duplicate key) → 이미 좋아요 상태였음

이 방식은 트래픽이 많아도
**완벽하게 race condition을 제어할 수 있는 유일한 방식**이야.

---

## 4) **코드도 더 단순해짐**

### 예: Next.js + MongoDB

```ts
try {
  await db.collection('likes').insertOne({
    user_id,
    target_type: 'post',
    target_id: postId
  });

  await db.collection('post').updateOne(
    { _id: postId },
    { $inc: { like_count: 1 } }
  );

  return res.status(204).end();

} catch (e) {
  // 중복 에러라면 no-op
  if (e.code === 11000) {
    return res.status(204).end(); // 이미 좋아요 상태 → 그냥 OK
  }
  throw e; // 다른 DB 에러는 서버 오류
}
```

끝.

**읽기 쿼리 없이 바로 처리 가능.**

---

## 5) 이는 **전형적인 upsert 패턴의 한 종류**

SQL(RDB)에서도 원래 이렇게 처리함:

* `INSERT ... ON CONFLICT DO NOTHING`
* `INSERT IGNORE`
* `INSERT ... ON DUPLICATE KEY UPDATE`

Mongo에서도 동일 개념.

> **좋아요 같은 기능은 충돌을 자연스럽게 무시하는 방식**이 정석.

---

# 🔥 반대로 "insert 하기 전에 체크하는 방식"의 단점 요약

| 문제                       | 설명              |
| ------------------------ | --------------- |
| race condition 해결 못함     | 동시에 요청 오면 중복 발생 |
| 쿼리 2번                    | read + write    |
| 서버 부하 증가                 | 트래픽 많아지면 병목     |
| 코드 길어짐                   | 유지보수 복잡         |
| 중복을 DB가 아닌 애플리케이션 로직에 맡김 | 비효율적            |

애플리케이션 레벨에서 중복을 막으려고 하면 무조건 복잡해짐.

---

# ✅ 최종 결론 (한 문장)

> **좋아요는 사전 체크 없이 바로 insert하고, UNIQUE 제약조건으로 중복을 잡는 방식이 가장 빠르고, 안전하고, 운영 친화적이다.**

---

원하면 바로 이어서:

* DELETE 요청(좋아요 해제)도 멱등적 구현 예제
* likes 테이블 인덱스 설계
* Next.js 클라이언트에서 optimistic UI 구현

까지 만들어줄게!


---

#7

좋아, 질문한 내용들 하나씩 **정확히** 설명해줄게.
아래 내용은 MongoDB + Next.js API 기준으로 아주 많이 쓰는 패턴이고, 개념을 정확히 이해하면 네가 만든 게시판이 훨씬 안정적으로 돌아가.

---

# ✅ 1) `{ $inc: { like_count: 1 } }` 이건 뭐야?

### 👉 MongoDB의 **증가 연산자**야.

* `$inc`: 숫자 필드를 원자적으로(atomic) 증가시키는 연산
* `like_count: 1` = 숫자를 1 증가
* `like_count: -1` = 숫자를 1 감소

### 🔥 여기서 중요한 점

**“원자적 증가(atomic increment)”**
→ 여러 요청이 동시에 와도 값이 정확하게 1씩 증가됨
→ race condition 없이 안전

SQL 기준으로는 이런 느낌:

```sql
UPDATE post SET like_count = like_count + 1 WHERE id = 123;
```

Mongo 버전이 `$inc`.

---

# ✅ 2) “좋아요 수를 그때그때 계산하는건가? 아니면 미리 저장하는건가?”

### 두 방법 모두 존재하지만, **좋아요 카운트를 필드에 저장하는 방식(캐싱)**이 훨씬 일반적이야.

방법 비교:

| 방식                                    | 설명                                   | 장점           | 단점                               |
| ------------------------------------- | ------------------------------------ | ------------ | -------------------------------- |
| **A. 실시간 COUNT 조회 (likes 컬렉션 count)** | `COUNT(*)` 또는 Mongo `countDocuments` | 데이터 정확도 100% | 트래픽 많으면 매우 느림 → 절대 비추            |
| **B. post에 like_count 필드를 저장 (캐시)**   | `$inc`로 증가/감소                        | 빠르고 확장성 높음   | DB와 카운트 값이 불일치할 수 있음 (하지만 극히 드묾) |

👉 **대부분의 서비스는 B번 방식(캐시 방식)** 사용
(인스타그램, 페이스북, 유튜브 모두 count 필드를 따로 관리함.)

---

# ✅ 3) `{ $inc }`는 post 객체 내부에 어떻게 반영되는거야?

너가 저장한 post 문서:

```json
{
  "_id": "...",
  "title": "제목",
  "content": "내용",
  "like_count": 3
}
```

이 상태에서

```js
{ $inc: { like_count: 1 } }
```

적용하면:

```json
{
  "like_count": 4
}
```

이렇게 **필드만 변경하는 업데이트 연산**이야.
문서 전체를 덮어쓰는 게 아님.

---

# ✅ 4) `204 No Content`는 왜 쓰는가?

### 👉 “서버가 요청을 정상 처리했지만, 돌려줄 데이터는 없음”

이라는 REST 표준 응답 코드.

좋아요 API는 보통 다음 행동들 중 하나:

* 성공했지만 프론트에 특별히 돌려줄 JSON은 없음
* UI는 프론트에서 optimistic update로 이미 반영됨
* 불필요한 바이트 전송을 줄여 네트워크 효율 UP

그래서 **좋아요/북마크/팔로우/언팔로우 등에서는 204를 많이 사용함**.

---

# ✅ 5) 중복 에러 코드 11000은 뭐야?

### 👉 MongoDB의 “duplicate key error” (unique 제약 위반)

예)
likes 컬렉션이 다음 unique 인덱스를 가진 경우:

```js
createIndex(
  { user_id: 1, target_type: 1, target_id: 1 },
  { unique: true }
)
```

이미 좋아요 상태인데 또 insert를 시도하면:

```
E11000 duplicate key error
```

이게 **11000 에러 코드**야.

---

# ✅ 6) “no-op”은 뭐야?

### 👉 No Operation = “아무 동작도 하지 않는다”라는 의미.

예:

* 이미 좋아요인 상태에서 insert → 중복 에러 발생
* 이 경우 좋아요를 새로 추가할 필요 없음
* 그래서 **그냥 성공한 것처럼 넘어가는 것**을 `no-op`이라고 함

결국 이 코드의 의미:

```js
if (e.code === 11000) {
  return res.status(204).end(); // 중복 → 이미 좋아요 → no-op → 성공 처리
}
```

즉,
**“좋아요 이미 눌려있네? 그럼 그냥 성공으로 처리해줄게.”**

---

# ✅ 전체 흐름을 그림으로 요약

### 1) 좋아요 insert 시도

→ 성공: like_count +1
→ 실패(11000 중복): 이미 좋아요 → no-op

### 2) 좋아요 해제 delete 시도

→ 성공: like_count -1
→ 실패(0개 삭제): 이미 해제 상태 → no-op

---

# 🧠 지금 네가 이해한 포인트

너가 방금 질문한 내용들은 사실 **좋아요 API의 핵심 구조**야.

* `$inc`는 필드 증가
* like_count는 실시간 조회가 아니라 캐시 저장
* 204는 “응답 줄 필요 없음”
* 11000은 duplicate error
* no-op은 “그냥 성공 처리”
* UNIQUE는 중복 좋아요 방지
* insert 실패에 의한 no-op은 race condition을 해결하는 정석 패턴

너 흐름 완벽히 이해하고 있음.
지금까지의 고민 방향 매우 정확해.

---

# 🔥 원하면 다음도 바로 만들어줄게

* **완성된 좋아요/좋아요 해제 API 코드**
* **post/comment 통합 likes 테이블 구조**
* **Optimistic UI 버튼 코드 (Next.js Client Component)**
* **레이스 조건 방지 전체 흐름도**

필요한 걸 말해줘!
